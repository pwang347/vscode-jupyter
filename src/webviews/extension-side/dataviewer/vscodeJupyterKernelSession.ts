// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

import * as vscode from 'vscode';
import { IKernelSession, KernelConnectionMetadataWithKernelSpecs } from './dataWranglerTypes';
import { KernelMessage, Kernel } from '@jupyterlab/services';
import { INTERRUPTED_ERROR, CodeOutputStreamListener, IRuntimeError } from '@dw/messaging';
import { cleanStackTrace, stripAnsiDeep } from './dataWranglerUtil';
import { IKernelConnectionInfo } from '../../../api';

/**
 * Jupyter implementation of the kernel session.
 */
export class VSCJupyterKernelSession implements IKernelSession {
    /** ID of the kernel session. */
    public id: string;

    /** Name of the kernel session. */
    public name: string;

    /** Type of kernel session. */
    // public type = KernelSessionType.VSCodeJupyter;

    private onStatusChangedEvent: vscode.EventEmitter<Kernel.Status> = new vscode.EventEmitter<Kernel.Status>();

    constructor(
        private connectionInfo: IKernelConnectionInfo,
        specs: KernelConnectionMetadataWithKernelSpecs
    ) {
        this.connectionInfo.connection.statusChanged.connect(this.onKernelStatus, this);
        this.onStatusChanged = this.onStatusChangedEvent.event;
        this.id = specs.id;
        this.name = specs.kernelSpec?.display_name ?? specs.id;
    }

    /**
     * Event listener for kernel status changes.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    public onStatusChanged: vscode.Event<any>;

    private onKernelStatus(_sender: Kernel.IKernelConnection, state: Kernel.Status) {
        this.onStatusChangedEvent.fire(state);
    }

    private async executeRequest(
        code: string,
        handleMessage: (message: KernelMessage.IMessage) => void
    ): Promise<void> {
        // create a new execution request
        const executeRequest = this.connectionInfo.connection.requestExecute({
            code,
            store_history: false
        });

        let canceled = false;
        executeRequest.onIOPub = (message: KernelMessage.IIOPubMessage) => {
            if (KernelMessage.isErrorMsg(message)) {
                if (message.content.ename === 'KeyboardInterrupt') {
                    canceled = true;
                }
            }
            handleMessage(message);
        };
        executeRequest.onReply = (message: KernelMessage.IExecuteReplyMsg) => {
            handleMessage(message);
        };

        await executeRequest.done;

        if (canceled) {
            throw INTERRUPTED_ERROR;
        }
    }

    /**
     * Executes the given code.
     */
    public async executeCode(
        code: string,
        options?: {
            outputStream?: CodeOutputStreamListener;
        }
    ): Promise<string> {
        // return the stdout as a newline-joined string
        const resultSoFar: string[] = [];
        let errorMessage;
        let errorType;
        let errorTrace: string[] = [];

        await this.executeRequest(code, (message: KernelMessage.IMessage) => {
            if (KernelMessage.isStreamMsg(message)) {
                // ignore stderr
                if (message.content.name === 'stderr') {
                    // TODO@DW: consider adding telemetry for warnings generated by us?
                    console.warn(message.content.text);
                } else {
                    resultSoFar.push(message.content.text);
                }

                // optionally handle pass output messages to the host
                options?.outputStream?.(message.content.text);
            } else if (KernelMessage.isErrorMsg(message)) {
                console.error(code, stripAnsiDeep(message.content));
                errorMessage = message.content.evalue;
                errorType = message.content.ename;
                errorTrace = message.content.traceback;
            } else if (KernelMessage.isExecuteReplyMsg(message) && message.content.status === 'error') {
                errorMessage = message.content.evalue;
                errorType = message.content.ename;
                errorTrace = message.content.traceback;
            }
        });

        if (errorMessage && errorType) {
            const error: IRuntimeError = {
                name: errorType,
                message: errorMessage,
                stack: cleanStackTrace(errorTrace)
            };
            throw error;
        }

        return resultSoFar.join('\n');
    }

    public interrupt() {
        return this.connectionInfo.connection.interrupt();
    }

    /**
     * Disposes the kernel session.
     */
    public dispose() {
        this.connectionInfo.connection.dispose();
    }
}
