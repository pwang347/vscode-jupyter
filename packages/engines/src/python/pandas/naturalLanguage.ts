import { IDataFrame, IDataFrameColumn } from "@dw/messaging";
import { ICompletionResult, INaturalLanguageClient } from "@dw/orchestrator";

/**
 * Generates code for an operation given the current context and a natural language prompt.
 */
export async function createWranglingCompletion(
    client: INaturalLanguageClient,
    variableName: string,
    dataFrame: IDataFrame,
    prompt: string
): Promise<ICompletionResult> {
    // add the prompt to history
    client.addPromptToHistory(prompt);

    const result = await client.createCompletion(`
Given a Pandas DataFrame currently named [ ${variableName} ].
${addContext(client, dataFrame, prompt)}
Code to solve [ ${prompt} ]. Store the new dataframe back to ${variableName}. Remove unused imports. ]?:
\`\`\`python
`);

    return {
        code: cleanupCompletion(variableName, result.code),
        foundNullCharacter: result.foundNullCharacter
    };
}

/**
 * Adds the current data frame context to the prompt.
 * Prioritize adding column context first, then data.
 *
 * Assumption: characters used <= tokens used
 */
export function addContext(client: INaturalLanguageClient, dataFrame: IDataFrame, prompt: string) {
    const { includeDataContext, includeColumnContext, maxTokens } = client.getParams();
    let result = "";
    const maxRows = 3;

    // strategy 1: include all columns and values
    if (includeColumnContext) {
        result += `The data types of the columns:\n\n${dataFrame.columns
            .map((col) => `${col.name}: ${col.rawType}`)
            .join("\n")}\n\n`;
    }
    if (includeDataContext) {
        const loadedRows = dataFrame.getLoadedRows();
        if (loadedRows.length > 0) {
            result += "Here are sample rows for the dataframe:\n\n";
            result += JSON.stringify(loadedRows[0].data) + "\n";

            let rowCount = 1;
            let lastValidResult = result;
            while (rowCount < loadedRows.length && rowCount <= maxRows && result.length + prompt.length < maxTokens) {
                lastValidResult = result;
                result += JSON.stringify(loadedRows[rowCount].data) + "\n";
                rowCount++;
            }

            result = `${lastValidResult}\n`;
        }
    }

    // strategy 2: if the result is too long, try including only contextual data
    if (result.length + prompt.length >= maxTokens) {
        result = "";
        const promptLowercase = prompt.toLowerCase();
        const relatedColumns = dataFrame.columns.filter((column) => {
            return promptLowercase.includes(column.name.toLowerCase());
        });

        if (includeColumnContext) {
            result += `Here are sample column types for the dataframe:\n\n${relatedColumns
                .map((col) => `${col.name}: ${col.rawType}`)
                .join("\n")}\n\n`;
        }
        if (includeDataContext) {
            const loadedRows = dataFrame.getLoadedRows();

            if (loadedRows.length > 0) {
                result += "Here are sample rows for the dataframe:\n";
                result += JSON.stringify(getSubsetRow(relatedColumns, loadedRows[0].data)) + "\n";

                let rowCount = 1;
                let lastValidResult = result;
                while (
                    rowCount < loadedRows.length &&
                    rowCount <= maxRows &&
                    result.length + prompt.length < maxTokens
                ) {
                    lastValidResult = result;
                    result += JSON.stringify(getSubsetRow(relatedColumns, loadedRows[rowCount].data)) + "\n";
                    rowCount++;
                }

                result = `${lastValidResult}\n`;
            }
        }
    }

    // strategy 3: if we're still somehow over the limit, just don't include any context
    if (result.length + prompt.length >= maxTokens) {
        return "";
    }

    return `\n${result}`;
}

function getSubsetRow(filterColumns: IDataFrameColumn[], row: any[]) {
    const newRow: any[] = [];
    for (const column of filterColumns) {
        newRow.push(row[column.index]);
    }
    return newRow;
}

/**
 * Cleans up the code generated by the completion.
 */
export function cleanupCompletion(variableName: string, code: string) {
    // Code post-processing
    let cleanCode = code;
    // Remove import pandas
    cleanCode = cleanCode.replace(/import pandas as pd/g, "");

    // Remove unused imports...
    // Extract imports
    const imports = cleanCode.match(/import .*/g);
    // Map imports to their variable names
    const importVariableMap = imports?.map((importStatement) => {
        // Consider imports such as "import re" and "import re as regex"
        // Identify when the import is aliased
        if (importStatement.includes(" as ")) {
            const [_, importVariable] = importStatement.split(" as ");
            return importVariable;
        } else {
            // If the import is not aliased, use the last part of the import statement as the variable name
            return importStatement.split(" ").pop();
        }
    });
    // Remove unused imports based on the variable names
    if (importVariableMap) {
        importVariableMap.forEach((importVariable) => {
            // Remove the import if it is not used in the code
            if (!code.includes(`${importVariable}.`)) {
                cleanCode = cleanCode.replace(new RegExp(`import.* ${importVariable}.*`), "");
            }
        });
    }

    // Remove entire lines when they contain "pd.read_csv" at any point in the line
    cleanCode = cleanCode.replace(/.*pd.read_csv.*/g, "");
    // Remove anything from `print(` to its closing `)` and the closing `)`
    cleanCode = cleanCode.replace(/print\(.*\)/g, "");
    // Remove df.head() (keep ones that aren't at the start, which are sometimes useful)
    cleanCode = cleanCode.replace(new RegExp(`^${variableName}.head\(.*\)`, "gm"), "");
    // Remove multi-line print statements
    cleanCode = cleanCode.replace(/print\("""[\s\S]*"""\)/g, "");
    // Remove lines that only contain spaces
    cleanCode = cleanCode.replace(/^\s+$/gm, "");
    // Remove empty lines
    cleanCode = cleanCode.replace(/(\r\n|\n|\r){2,}/gm, "\n");
    // Remove trailing and leading whitespace and newlines
    cleanCode = cleanCode.trim();

    return cleanCode;
}
